# Lab 7

## 练习 1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

1. 请在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程。

    * 在 kern/sync/sync.h 中，包含了开关中断的操作。

    * 在 kern/sync/sem.c 中，实现了内核级信号量，包含了以下函数：

        1. `sem_init`
            初始化信号量。信号量包含了一个当前值与一个对应的等待队列，此函数将它们设定为正确的初始值。
        
        2. `up`
            调用了 `__up()`，要求被唤醒的进程处于 `WT_KSEM` 的等待状态。
        
        3. `down`
            调用了 `__down()`，使进入等待状态的进程处于 `WT_KSEM` 的等待状态。
        
        4. `__up`
            对信号量进行 V 操作，在操作过程中中断是被屏蔽的。如果没有进程处于等待信号量的状态，那么将信号量当前值加一，否则唤醒这个等待的进程。
        
        5. `__down`
            对信号量进行 P 操作。首先屏蔽中断，如果信号量当前值大于零，当前进程不必阻塞，信号量当前值减一，恢复中断之后函数返回。如果信号量当前值等于零，并将当前进程挂到信号量的等待队列中，恢复中断，并进入进程调度。在进程再次得到调度时，屏蔽中断，将当前进程从信号量的等待队列中移除，恢复中断。

2. 请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。

用户态进程/线程提供的信号量机制应该功能更加强大且易于使用，例如，Linux 中至少提供了如下函数：

    1. `sem_init`
        以指定的初始值初始化信号量，并指明信号量是进程内共享还是进程间共享。
    
    2. `sem_post`
        对信号量进行 V 操作。
    
    3. `sem_wait`
        对信号量进行 P 操作。
    
    4. `sem_trywait`
        是 `sem_wait` 的非阻塞版本，即如果信号量当前值为 0，不阻塞而是返回错误。
    
    5. `sem_timedwait`
        是 `sem_wait` 的限定时间阻塞版本，即如果信号量当前值为 0，则阻塞至多指定的时间。函数返回值表明了成功取得信号量或等待超时。
    
    6. `sem_destroy`
        销毁信号量。
