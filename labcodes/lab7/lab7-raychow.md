# Lab 7

## 练习 1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

1. 请在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程。

    * 在 kern/sync/sync.h 中，包含了开关中断的操作。

    * 在 kern/sync/sem.c 中，实现了内核级信号量，包含了以下函数：

        1. `sem_init`
            初始化信号量。信号量包含了一个当前值与一个对应的等待队列，此函数将它们设定为正确的初始值。
        
        2. `up`
            调用了 `__up()`，要求被唤醒的进程处于 `WT_KSEM` 的等待状态。
        
        3. `down`
            调用了 `__down()`，使进入等待状态的进程处于 `WT_KSEM` 的等待状态。
        
        4. `__up`
            对信号量进行 V 操作，在操作过程中中断是被屏蔽的。如果没有进程处于等待信号量的状态，那么将信号量当前值加一，否则唤醒这个等待的进程。
        
        5. `__down`
            对信号量进行 P 操作。首先屏蔽中断，如果信号量当前值大于零，当前进程不必阻塞，信号量当前值减一，恢复中断之后函数返回。如果信号量当前值等于零，并将当前进程挂到信号量的等待队列中，恢复中断，并进入进程调度。在进程再次得到调度时，屏蔽中断，将当前进程从信号量的等待队列中移除，恢复中断。

2. 请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。

用户态进程/线程提供的信号量机制应该功能更加强大且易于使用，例如，Linux 中至少提供了如下函数：

    1. `sem_init`
        以指定的初始值初始化信号量，并指明信号量是进程内共享还是进程间共享。
    
    2. `sem_post`
        对信号量进行 V 操作。
    
    3. `sem_wait`
        对信号量进行 P 操作。
    
    4. `sem_trywait`
        是 `sem_wait` 的非阻塞版本，即如果信号量当前值为 0，不阻塞而是返回错误。
    
    5. `sem_timedwait`
        是 `sem_wait` 的限定时间阻塞版本，即如果信号量当前值为 0，则阻塞至多指定的时间。函数返回值表明了成功取得信号量或等待超时。
    
    6. `sem_destroy`
        销毁信号量。

## 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题

1. 请在实验报告中给出内核级条件变量的设计描述，并说明其大致执行流流程。

在 kern/sync/moniter.c 中，实现了内核级条件变量，包含了以下函数：

    1. `monitor_init`
        以指定的条件变量数量初始化管程。
    
    2. `cond_wait`
        等待某个条件变量。此操作会唤醒一个相关进程（即等待进入管程的进程或由于发出信号而阻塞的进程）。
    
    3. `cond_signal`
        向某个条件变量发出信号。如果此条件变量有等待者，就唤醒一个等待者，而自身阻塞。

2. 请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。

用户态进程/线程提供的条件变量机制应该功能更加强大且易于使用，例如，Linux 中至少提供了如下函数：

    1. `cond_init`
        初始化条件变量。
    
    2. `cond_wait`
        等待条件变量。
    
    3. `cond_timedwait`
        等待条件变量，最多等待到指定的绝对时刻。
    
    4. `cond_reltimedwait`
        等待条件变量，最多等待指定的时间。
    
    5. `cond_signal`
        向某个条件变量发出信号，唤醒某一个等待的进程。
    
    6. `cond_broadcast`
        向某个条件变量发出信号，唤醒所有等待的进程。
    
    7. `cond_destroy`
        销毁条件变量。
