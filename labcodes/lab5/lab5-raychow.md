# Lab 5

## 练习 1: 加载应用程序并执行

* 设计实现过程

    1. `load_icode` 函数负责加载根据 ELF 信息加载应用程序到内存中，并建立好应用程序的内存空间；
    2. 在最后，需要设置进程的中断帧，这样之后就能通过 `forkrets` 来切换到正确的应用程序上下文中；
    3. 具体的设置方式是，将 `cs` 设置为 `USER_CS`，而 `ds`、`es`、`ss` 设置为 `USER_DS`，`esp` 设置为 `USTACKTOP`，`eip` 设置为 ELF 信息中程序代码的入口虚地址，并设置 `eflags` 中的 `FL_IF` 位，以在用户态程序中使能中断。

* 描述当创建一个用户态进程并加载了应用程序后，CPU 是如何让这个应用程序最终在用户态执行起来的。

    1. `load_icode` 执行完成后，应用程序被加载到当前进程中，且当前进程的中断帧保存了应用程序执行的上下文；
    2. `SYS_exec` 系统调用结束，中断返回时，`iret` 指令恢复了应用程序的上下文，使得应用程序在用户态执行起来。

## 练习 2: 父进程复制自己的内存空间给子进程

* 设计实现过程

    1. 取得源页面与目的页面的内核虚拟地址；
    2. 使用 `memcpy` 将源页面复制到目的页面；
    3. 将目的页面映射到目的页表中。

* 请在实验报告中简要说明如何设计实现 "Copy on Write" 机制
* 扩展练习 Challenge: 实现 Copy on Write 机制

    1. 当 `fork` 进程时，并不将父进程的内存空间复制给 `fork` 出的子进程，在复制内存时，修改了 `copy_range()` 的实现，如果某个内存区域是堆栈，则正常复制，否则先将区域中的每个页表项的 `PTE_W` 位清除，再将子进程此区域的页表项设置为与父进程相应区域的页表项相同；
    2. 此时，父进程与子进程都能正常的读取内存，但任何一方写入内存，都会导致发生页面异常，为了正常处理真正的访问异常与 COW 机制引起的异常，修改 `do_pgfault()` 的逻辑：
        1. 如果 `error_code` 指示了错误是写入存在的页面引起的，而此 `vma` 指示此页面能被写入，则是由 COW 机制引起的异常；
        2. 在发生此异常时，将发生异常的整个内存区域都重新复制一份，并更新当前进程的页表，将相应页表项指向新的位置，并根据情况设置 `PTE_W` 位。

    注 1：未实现页面被换出时的 COW 机制；
    
    注 2：实现代码在分支 lab5-challenge 中；
    
    注 3：测试代码在 lab5/user/testscow.c 中，倘若将 `ARRAYSIZE` 扩大为 1024*4，在运行时就会发生中断帧中堆栈指针异常的问题，原因尚不明确。

* 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

1. 请在实验报告中简要说明你对 fork/exec/wait/exit 函数的分析。

    1. 这四个函数都是用户进程可调用的函数，它们的作用是发起相应的系统调用，而系统调用是通过软件中断来完成的；
    2. `fork()` 最主要的功能在内核态函数 `do_fork()` 中实现，此函数创建一个新的进程，并将被 `fork` 的进程设置为新进程的父进程，完成设置进程的内核堆栈、复制内存空间以及堆栈帧与上下文的初始化操作，最后将进程插入进程列表并唤醒进程，此时新进程几乎是父进程的克隆，可以等待调度；
    3. `exec()` 最主要的功能在内核态函数 `do_execve()` 中实现，此函数首先设置进程的基本信息，接着释放进程的内存空间，通过 ELF 信息载入新程序的信息并完成中断帧的设置，此时进程做好了执行一个新程序的准备;
    4. `wait()` 最主要的功能在内核态函数 `do_wait()` 中实现，如果指定的 `pid` 为 0，则寻找一个处于 `PROC_ZOMBIE` 状态的子进程，如果不为 0，则寻找指定的子进程，如果进程不在 `PROC_ZOMBIE` 状态，则睡眠直到满足条件为止，找到后，终止子进程；
    5. `exit()` 最主要的功能在内核态函数 `do_exit()` 中实现，此函数首先释放进程的内存空间，并将状态设置为 `PROC_ZOMBIE`，设置错误码，如果父进程处于 `WT_CHILD` 状态，还要唤醒父进程，之后重新设定进程链表，最后调用 `schedule()` 进入调度。

2. 请给出 ucore 中一个用户态进程的执行状态生命周期图。

盗图一张：
                                                
      alloc_proc                                 RUNNING
          +                                   +--<----<--+
          +                                   + proc_run +
          V                                   +-->---->--+ 
    PROC_UNINIT -- proc_init/wakeup_proc --> PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --> PROC_SLEEPING --
                                               A      +                                                          +
                                               |      +--- do_exit --> PROC_ZOMBIE                               +
                                               +                                                                 + 
                                               -----------------------wakeup_proc---------------------------------
