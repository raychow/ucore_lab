# Lab 4

## 练习 1: 加载应用程序并执行

* 设计实现过程

    1. `load_icode` 函数负责加载根据 ELF 信息加载应用程序到内存中，并建立好应用程序的内存空间；
    2. 在最后，需要设置进程的中断帧，这样之后就能通过 `forkrets` 来切换到正确的应用程序上下文中；
    3. 具体的设置方式是，将 `cs` 设置为 `USER_CS`，而 `ds`、`es`、`ss` 设置为 `USER_DS`，`esp` 设置为 `USTACKTOP`，`eip` 设置为 ELF 信息中程序代码的入口虚地址，并设置 `eflags` 中的 `FL_IF` 位，以在用户态程序中使能中断。

* 描述当创建一个用户态进程并加载了应用程序后，CPU 是如何让这个应用程序最终在用户态执行起来的。

    1. `load_icode` 执行完成后，应用程序被加载到当前进程中，且当前进程的中断帧保存了应用程序执行的上下文；
    2. `SYS_exec` 系统调用结束，中断返回时，`iret` 指令恢复了应用程序的上下文，使得应用程序在用户态执行起来。

## 练习 2: 父进程复制自己的内存空间给子进程

* 设计实现过程

    1. 取得源页面与目的页面的内核虚拟地址；
    2. 使用 `memcpy` 将源页面复制到目的页面；
    3. 将目的页面映射到目的页表中。

* 请在实验报告中简要说明如何设计实现 "Copy on Write" 机制
* 扩展练习 Challenge: 实现 Copy on Write 机制

    1. 当进程 `fork` 自身时，并不将自身的内存空间复制给 `fork` 出的子进程，而是使用相同的 `mm_struct`，并且增加 `mm_struct` 的引用计数；
    2. 将页目标表项的 `PTE_W` 位清除；
    3. 此时，父进程与子进程都能正常的读取内存，但任何一方写入内存，都会导致发生页面异常，为了正常处理真正的访问异常与 COW 机制引起的异常，修改 `do_pgfault()` 的逻辑：
        1. 如果错误是由写入引起的，而 `vma_struct` 中未设置 `VM_WRITE` 位，表示访问异常（此逻辑不变）；
        2. 否则，如果页表项中设置了 `PTE_P` 位，说明页面在内存中，检查 `mm_struct` 的引用计数，如果大于 1，说明有其它进程共享了内存空间，因此使用 `copy_mm()` 复制 `mm_struct`，如果等于 1，根据 `mm_struct` 中每个 `vma_struct` 的可写性重新设置相应页表项的写入权限；
        3. 如果页表项为 0，说明此页面尚不存在，按步骤 2 中的操作复制 `mm_struct` 或修改写入权限，之后分配页面；
        4. 如果页表项不为 0，且未设置 `PTE_P` 位，说明页面已被换出，ucore 内核并未实现对换出页面的复制，暂时不做处理。

    注 1：未实现页面被换出时的 COW 机制；
    
    注 2：实现代码在分支 lab5-challenge 中。
